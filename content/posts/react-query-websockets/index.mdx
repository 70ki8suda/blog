---
title: Using WebSockets with React Query
description:
date: 2021-06-06
banner: ./react-query-websockets.jpeg
tags:
    - react
    - react-query
    - JavaScript
    - TypeScript
---

import Comments from 'components/Comments'
import Attribution from 'components/Attribution'

<img src="./react-query-websockets.jpeg" />

<Attribution name="Maxim Hopman" url="https://unsplash.com/@nampoh" />

-   [#1: Practical React Query](practical-react-query)
-   [#2: React Query Data Transformations](react-query-data-transformations)
-   [#3: React Query Render Optimizations](react-query-render-optimizations)
-   [#4: Status Checks in React Query](status-checks-in-react-query)
-   [#5: Testing React Query](testing-react-query)
-   [#6: React Query and TypeScript](react-query-and-type-script)
-   <b>#7: Using WebSockets with React Query</b>

---

How to handle live data using WebSockets together with React Query has been one of the most asked questions lately, so I thought I'd give it a try, play around with it a bit and report my findings. That's what this post is about :)

### What are WebSockets

Simply put, WebSockets allow push messages, or "live data", to be sent from the server to the client (browser). Usually with HTTP, the client makes a request to the server, specifying that they would like some data please, the server responds with that data or an error and then the connection closes.

Since the client is the one opening the connections and initiating the requests, that leaves no room for the server to push data to the client when the server knows that an update is available.

That's where [WebSockets](https://en.wikipedia.org/wiki/WebSocket) kick in.

Like with any other HTTP request, the browser initiates the connection, but indicates that they would like to upgrade the connection to a WebSocket. If the server accepts this, they will then switch the protocol. This connection will not terminate, but will stay open until either side decides to close it. Now, we have a fully functioning by-directional connection open, where both sides can transmit data.

This has the main advantage that the server can now push selective updates to the client. This can come in very handy if you have multiple users viewing the same data, and one user makes an update. Usually, the other clients will not see that update until they actively refetch. WebSockets allow to instantly push those updates in real-time.

### React Query integration

Since React Query is primarily a client side async state management library, I will _not_ talk about how to set up WebSockets on the server. I've honestly never done it, and it also depends on which technology you are using in the backend.

React Query doesn't have anything built-in specifically for WebSockets. That doesn't mean that WebSockets are not supported or that they don't work well with the library. It's just that React Query is _very_ agnostic when it comes to how you fetch your data: All it needs is a resolved or rejected _Promise_ to work - the rest is up to you.

### Step by Step

The general idea is to setup your queries as usual, as if you wouldn't be working with WebSockets. Most of the time, you will have your usual HTTP endpoints to query and mutate entities.

```jsx:title=a-standard-query
const usePosts = () => useQuery(['posts'], fetchPosts)
const usePost = (id) => useQuery(['posts', id], () => fetchPost(id))
```

Additionally, you can setup an app-wide _useEffect_ that connects you to your WebSocket endpoint. How that works totally depends on which technology you are using. I've seen people subscribe to live data from [Hasura](https://github.com/tannerlinsley/react-query/issues/171#issuecomment-649810136). There's a great article about connecting to [Firebase](https://aggelosarvanitakis.medium.com/a-real-time-hook-with-firebase-react-query-f7eb537d5145). In my example, I will simply use the browser native [WebSocket API](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket):

```jsx:title=useReactQuerySubscription
const useReactQuerySubscription = () => {
    React.useEffect(() => {
        const websocket = new WebSocket('wss://echo.websocket.org/')
        websocket.onopen = () => {
            console.log('connected')
        }

        return () => {
            websocket.close()
        }
    }, [])
}
```

#### Consuming data

After we've setup the connection, we will likely have some sort of callback that will be called when data comes in over the websocket. Again, what that data is depends entirely on how you'd like to set it up. Inspired by [this message](https://github.com/tannerlinsley/react-query/issues/171#issuecomment-649716718) from [Tanner Linsley](https://github.com/tannerlinsley), I like to send _events_ from the backend instead of complete data objects:

```jsx:title=event-based-subscriptions {8-12}
const useReactQuerySubscription = () => {
    const queryClient = useQueryClient()
    React.useEffect(() => {
        const websocket = new WebSocket('wss://echo.websocket.org/')
        websocket.onopen = () => {
            console.log('connected')
        }
        websocket.onmessage = (event) => {
            const data = JSON.parse(event.data)
            const queryKey = [data.entity, data.id].filter(Boolean)
            queryClient.invalidateQueries(queryKey)
        }

        return () => {
            websocket.close()
        }
    }, [queryClient])
}
```

That's really all you need to make list and detail views update when you receive an event.

-   `{ "entity": "posts" }` will invalidate the posts list
-   `{ "entity": "posts", id: 5 }` will invalidate a single post

This approach avoids the problem of over pushing, because if we receive an event for an entity that we are not interested in at the moment, nothing will happen. For example, if we are currently on the _Profile_ page, and we receive an update for _Posts_, _invalidateQueries_ will make sure that the next time we get to our _Posts_ page, it will be refetched. But it will not refetch it right now, because we have no active observers.

---

That's it for today. Feel free to reach out to me on [twitter](https://twitter.com/tkdodo)
if you have any questions, or just leave a comment below ⬇️

<Comments withSeparator={false} />
