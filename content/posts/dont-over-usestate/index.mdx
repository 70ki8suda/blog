---
title: Don't over useState
description: Avoid using state too often - lots of things aren't even state at all...
date: 2020-08-29
banner: ./use-state-pitfalls.png
tags:
    - React
    - useState pitfalls
---

`useState` is considered to be the most basic of all the hooks provided by React.
It is also the one you are most likely to use (no pun intended), alongside `useEffect`.

Yet over the last couple of months, I have seen this hook being misused a lot.
This has mostly nothing to do with the hook itself, but because state management is never easy.

This is the first part of a series I'm calling _useState pitfalls_,
where I will try to outline common scenarios with the useState hook that might better be solved differently.

### What is state?

I think it all boils down to understanding what state is.
Or more precisely, what state _isn't_.
To comprehend this, we have to look no further than
[the official react docs](https://reactjs.org/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state):

> Ask three questions about each piece of data:

> Is it passed in from a parent via props? If so, it probably isn’t state.
> Does it remain unchanged over time? If so, it probably isn’t state.
> Can you compute it based on any other state or props in your component? If so, it isn’t state.

So far, so easy. Putting _props to state_ (1) is a whole other topic I will probably write about another time,
and if you are not using the setter (2), then it it probably pretty obvious that we are _not_ dealing with state.

That leaves the third question: _derived state_.
It might seem pretty apparent that a value that can be computed from a state value is _not_ it's own state.
However, when I reviewed some code challenges for a client of mine lately, this is exactly the pattern I have seen a lot,
even from senior candidates.

### An example

The exercise is pretty simple and goes something like this:
Fetch some data from a remote endpoint (a list of items with categories) and let the user filter by the category.

The way the state was managed mostly was something like this:

```jsx:title=use-state
import { fetchData } from 'api'
import { getCategoriesFromData } from 'utils'

const App = () => {
    const [data, setData] = React.useState(null)
    const [categories, setCategories] = React.useState([])

    React.useEffect(() => {
        async function fetch() {
            const response = await fetchData()
            setData(response.data)
        }

        fetch()
    }, [getRemoteData])

    React.useEffect(() => {
        if (data) {
            setCategories(getCategoriesFromData(data))
        }
    }, [data, getCategoriesFromData])

    return <>...</>
}
```

At first glance, this looks okay. You might be thinking:
We have an effect that fetches the data for us, and another effect that keeps the categories _in sync_ with the data.
This is exactly what the useEffect hook is for (keeping data in sync), so what is bad about this approach?

### Getting out of sync
