---
title: The power of const assertions
description:
date: 2020-10-07
banner: ./power.jpg
tags:
    - TypeScript
---

import Attribution from 'components/Attribution'
import Comments from 'components/Comments'

<img src="./power.jpg" />

<Attribution name="Jack B" url="https://unsplash.com/@nervum" />

[const assertions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)
were introduced in TypeScript 3.4, so they are not exactly new (March 2019),
yet I have seen that many developers are still unaware of that feature.

Maybe it's the syntax that makes it a bit weird sometimes (writing `const something = ... as const`),
or maybe it's the resemblance to type casts that make people afraid of using them.
Or maybe you just got some weird errors regarding _readonly_, so you decided to not dig deeper.

In this Article, I'd like clear up the confusion and crush all doubts about const assertions.

### const assertions are _not_ type casts

Type casts are, simply put, evil.
They are meant to tell the compiler: "I know what I am doing, and I know it better than you".

Frankly, most of the time, developers _do not_ know better than the compiler.
So unless there is a really good reason, do not use type casts.

Here are some examples of what type casts allow you to do:

```ts:title=type-casts
type Foo = 'foo'
const foo = 'bar' as Foo

type Obj = { foo: Foo }
const obj = {} as Obj
```

[TypeScript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAYg9nKBeKByAZg1BYAUAYzgDsBnYKTRFVAIwEMAnVKOk2BPPUSKAeRoBWyKAG8KCAFztEAXzyFS5OIOEiZLNvwF4gA)

TypeScript is fine with that, because the type sufficiently overlap (string with 'foo' and object with Obj).
Of course, that is just false, but by using type casts, the compiler will yield to you.

This can be troublesome, even in cases where you think you are right. Consider the following example:

```ts:title=strings-inferred
type Variant = 'primary' | 'secondary'

type Props = {
    variant: Variant
}

const Component = (props: Props) => void 0

const props = { variant: 'primary' }

Component(props)
```

[TypeScript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQiKiMiqKuPhIRAgkUJqc7IbGpuhWAkIOQA)

Here, the compiler will complain with:

```
Argument of type '{ variant: string; }' is not assignable to parameter of type 'Props'.
  Types of property 'variant' are incompatible.
    Type 'string' is not assignable to type 'Variant'.(2345)
```

because variant will be inferred to string.
TypeScript is doing this because nothing stops you from re-assigning another string to variant:

```ts:title=re-assign-object-properties {10}
type Variant = 'primary' | 'secondary'

type Props = {
    variant: Variant
}

const Component = (props: Props) => void 0

const props = { variant: 'primary' }
props.variant = 'somethingElse'

Component(props)
```

[TypeScript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQiKiMiqKuPhIRAgkUJrsQZQAdLLIqiI4lEYQwAAWSKgA5gCiADbUbJzshsam6FYCQg5AA)

Even though we define a _const_, objects in JavaScript are still mutable, so inferring the string literal 'primary' would be wrong.
A type cast would solve this:

```ts:title=casting-props {9}
type Variant = 'primary' | 'secondary'

type Props = {
    variant: Variant
}

const Component = (props: Props) => void 0

const props = { variant: 'primary' } as Props

Component(props)
```

[TypeScript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQiKiMiqKuPhIRAgkUOpQcML2Qr6GxqboVgJCDkA)

All good - except, it isn't.
For the same reasons I mentioned earlier, if we remove primary from our _Variant_ type, we will not get a type error here.
This means that, like many solutions, this is something that works now, but is not very future proof.

Making your software resilient to change is, in my opinion, one of the true benefits of using TypeScript.
Achieving resilience requires the right mindset, which includes abandoning type casts.

For this scenario, the easiest solution (assuming that inlining the object is not an option)
would be to use an explicit type annotation rather than a type cast:

```ts:title=annotating-props {9}
type Variant = 'primary' | 'secondary'

type Props = {
    variant: Variant
}

const Component = (props: Props) => void 0

const props: Props = { variant: 'primary' }

Component(props)
```

[TypeScript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQnYCQiKiMiqKuPhIRAgkUJqc7IbGpuhWoZQOQA)

This is likely what most of you are doing right now, and it is perfectly fine regarding type-safety.

### Using const assertions

I still think that fixing the issue with const assertions is the preferred way of doing it:

```ts:title=const-assertions {9}
type Variant = 'primary' | 'secondary'

type Props = {
    variant: Variant
}

const Component = (props: Props) => void 0

const props = { variant: 'primary' } as const

Component(props)
```

[TypeScript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQiKiMiqKuPhIRAgkUOpQcML+apzshsam6FYCQg5AA)

This comes in handy if you don't have the type available for annotation, for example, because it has not been exported from a library you are using.
The syntax is also more terse, and using const assertions has other benefits as well.
Because you are signalling TypeScript that your object is _really_ constant, the compiler can make better assumptions about your intentions:

-   strings and numbers can be inferred as their literal counterparts
-   arrays become tuples with a fixed length
-   everything is readonly

This will give you a ton of flexibility when working with that constant on type level.

### Extracting Types from Objects or Arrays

### A note to library authors

<Comments>Leave a comment below ⬇️</Comments>
