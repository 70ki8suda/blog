---
title: Practical React Query
description:
date: 2020-11-14
banner: ./react-query.png
tags:
    - react
    - react-query
---

import Comments from 'components/Comments'
import { Divider } from '@theme-ui/components'

<img src="./react-query.png" />

<Divider />

When GraphQL and especially [Apollo Client](https://www.apollographql.com/docs/react/)
became popular in ca. 2018, there was a lot of fuss about it completely replacing redux, and the question
[Is Redux dead yet?](https://dev.to/markerikson/redux---not-dead-yet-1d9k) has been asked a lot.

I distinctly remember not understand what this was all about.
Why would some data fetching library replace your global state manager? What does one even have todo with the other?

I was under the impression that GraphQl clients like Apollo would only fetch the data for you,
like for example [axios](https://github.com/axios/axios) does for REST,
and that you would still obviously need some way of making that data accessible to your application.

I couldn't have been more wrong.

### Client State vs. Server State

What Apollo gives you is not just the ability to fetch data, it also comes with a _cache_ for that server data.
This means that you can just use the same `useQuery` hook in multiple components,
and it will only fetch the data once and then subsequently return the data from the cache.

This sounds _very_ familiar with what we, and probably many other teams as well, have mainly been using _redux_ for:
Fetch the data from the server and make it available everywhere.

So it seems that we have always been treating this _server state_ like any other _client state_.
Except that when it comes to _server state_ (think: A list of articles that you fetch,
the details of a User you want to display, ...), your app does not own it.
We have only borrowed it to display the most recent version of it on the screen for the user.
It is the server who owns the data.

To me, that introduced a paradigm shift in how to think about data.
If we can leverage the cache to display data that we do not own,
there isn't really much left that is real client state that _also_ needs to be made available to the whole app.
That made me understand why many think that Apollo can replace redux in lots of instances.

### React Query

I have never had the chance to use GraphQL.
As far as I'm aware, it requires a GraphQL Server, it's not the simplest thing to set up (schemas, resolvers, ...)
and we've just never gotten around to adopt that.

There is an existing REST API, we don't really experience problems with over-fetching, it just works,
and clearly, there weren't enough pain points to warrant a switch.

But I still envied the simplicity of how data fetching can look like on the client,
including the handling of loading and error states. If only there were something similar in React for REST APIs...

Enter [React Query](https://react-query.tanstack.com/).

Innovated by the open sourcerer [Tanner Linsley](https://github.com/tannerlinsley) in late 2019,
React Query takes the good parts of Apollo and brings them to REST.
It works with any function that returns a Promise and embraces the _stale-while-revalidate_ caching strategy.
It operates on sane defaults that try to keep your data as fresh as possible
while at the same time showing data to the user as early as possible,
making it feel near instant at times and thus providing a great UX.
On top of that, it is also very flexible and lets you customize various settings for when the defaults are not enough.

This is not going to be an introduction to React Query though.
I think the docs are great at explaining Guides & Concepts,
there are [Videos](https://react-query.tanstack.com/docs/videos) from various Talks that you can watch,
and Tanner has a React Query [Essentials Course](https://learn.tanstack.com/) you can take if you want to get familiar with the library.

I want to focus more on some practical tips that go beyond the docs that might be useful when you are trying out the library.
These are things I have picked up over the last couple of months when I was not only actively using the library at work,
but also became involved in the React Query community, answering questions on Discord and in GitHub Discussions.

#### The Defaults explained

I believe the React Query [Defaults](https://react-query.tanstack.com/docs/guides/important-defaults)
to be very well chosen, but they can catch you off guard from time to time, especially at the beginning.

First of all: React Query does _not_ invoke the queryFn on every re-render, even with the default _staleTime_ of zero.
Your app can re-render for various reasons at any time, so fetching every time would be insane!

> Always code for re-renders, and a lot of them. I like to call it render resiliency.

<p style="padding-left: 3rem; margin-top: -1rem">— Tanner Linsley</p>

If you see a re-fetch that you are not expecting, it is likely because you just focused the window
and React Query is doing a _refetchOnWindowFocus_, which is a great feature for production:
If the user goes to a different browser tab, and then comes back to your app,
a background refetch will be triggered automatically,
and data on the screen will be updated if something has changed on the server in the meantime.
All of this happens without a loading spinner being shown,
and your component will not re-render if the data is the same as you currently have in the cache.

During development, this will probably be triggered more frequently,
especially because focussing between the Browser DevTools and your app will also cause a fetch, so be aware of that.

Secondly, there seems to be a bit of confusion between _cacheTime_ and _staleTime_, so let me try to clear that up:

-   StaleTime: The duration until a query transitions from fresh to stale.
    As long as the query is fresh, the data will always be read from the cache only - no network request will happen.
    If the query is stale (which per default is: instantly), you will still get the data from the cache,
    but a background can happen _under certain conditions_, like:
    -   the window is focussed,
    -   the user lost and re-gains his network connection,
    -   the query key changes,
    -   and most prominently: A new _observer_ (i.e. a new component which does `useQuery`) mounts
-   CacheTime: The duration until inactive queries will be removed from the cache. This defaults to 5 minutes.
    Queries transition to the inactive state as soon as there are no active observers,
    so when all components which use that query have unmounted.

There is a good [explanation by example](https://react-query.tanstack.com/docs/guides/caching#a-detailed-caching-example)
in the docs as well.

#### Use the React Query DevTools

This will help you immensely in understanding the state a query is in.
The DevTools will also tell you what data is currently in the cache, so you'll have an easier time debugging.
In addition to that, I have found that it helps to throttle your network connection in the browser DevTools
if you want to better recognize background refetches, since dev-servers are usually pretty fast.


#### Don't use the queryCache as a local state manager

If you temper with the queryCache (_queryCache.setData_), it should only be for optimistic updates
or for writing data that you receive from the backend after a mutation.
Remember that every background refetch might override that data, so
[use](https://reactjs.org/docs/hooks-state.html)
[something](https://zustand.surge.sh/)
[else](https://redux.js.org/) for local state.

<Comments>Have you worked with React Query yet? Let me know in the comments below ⬇️</Comments>
