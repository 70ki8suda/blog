---
title: Leveraging the Query Context
description:
date: 2021-10-24
banner: ./context.jpeg
tags:
  - react
  - react-query
  - JavaScript
  - TypeScript
---

import Comments from 'components/Comments'
import Attribution from 'components/Attribution'
import Highlight from 'components/Highlight'

<img src="./context.jpeg" />

<Attribution
  name="mohammad takhsh"
  url="https://unsplash.com/@mohammadtkh"
/>

- [#1: Practical React Query](practical-react-query)
- [#2: React Query Data Transformations](react-query-data-transformations)
- [#3: React Query Render Optimizations](react-query-render-optimizations)
- [#4: Status Checks in React Query](status-checks-in-react-query)
- [#5: Testing React Query](testing-react-query)
- [#6: React Query and TypeScript](react-query-and-type-script)
- [#7: Using WebSockets with React Query](using-web-sockets-with-react-query)
- [#8: Effective React Query Keys](effective-react-query-keys)
  - <b>#8a: Leveraging the Query Context</b>
- [#9: Placeholder and Initial Data in React Query](placeholder-and-initial-data-in-react-query)
- [#10: React Query as a State Manager](react-query-as-a-state-manager)
- [#11: React Query Error Handling](react-query-error-handling)
- [#12: Mastering Mutations in React Query](mastering-mutations-in-react-query)

---

We all strive to improve as engineers, and as time goes by, we hopefully succeed in that endeavour. Maybe we learn new things that invalidate or challenge our previous thinking. Or we realise that patterns that we thought ideal would not scale to the level we now need them to.

Quite some time has passed since I first started to use React Query. I think I learned a great deal on that journey, and I've also "seen" a lot. I want my blog to be as up-to-date as possible, so that you can come back here and re-read it, knowing that the concepts are still valid. This is now more relevant than ever since [Tanner Linsley](https://twitter.com/tannerlinsley) agreed to link to my blog from the official [React Query documentation](https://react-query.tanstack.com/community/tkdodos-blog).

That's why I've decided to write this addendum to my [Effective React Query Keys](effective-react-query-keys) article. Please make sure to read it first to have an understanding of what we are talking about.

### Hot take

<Highlight>
  Don't use inline functions - leverage the Query Context given to you, and
  use a Query Key factory that produces object keys
</Highlight>

Inline functions are by far the easiest way to pass props to your _queryFn_, because they let you closure over other variables available in your custom hook. Let's look at the evergreen todo example:

```ts:title=inline-query-fn
type State = 'all' | 'open' | 'done'
type Todo = {
  id: number
  state: TodoState
}
type Todos = ReadonlyArray<Todo>

const fetchTodos = async (state: State): Promise<Todos> => {
  const response = await axios.get(`todos/${state}`)
  return response.data
}

export const useTodos = () => {
  // imagine this grabs the current user selection
  // from somewhere, e.g. the url
  const { state } = useTodoParams()

  // ‚úÖ The queryFn is an inline function that
  // closures over the passed state
  return useQuery(['todos', state], () => fetchTodo(state))
}
```

Maybe you recognize the example - It's a slight variation of [#1: Practical React Query - Treat the query key like a dependency array](practical-react-query#treat-the-query-key-like-a-dependency-array). This works great for simple examples, but it has a quite substantial problem when having lots of parameters. In bigger apps, it's not unheard of to have lots of filter and sorting options, and I've personally seen up to 10 params being passed.

I like to approach these things from the bottom up - starting with the _queryFn_ and letting the compiler tell me what I need to change next:

```ts:title=sorting-todos {1,4,6}
type Sorting = 'dateCreated' | 'name'
const fetchTodos = async (
  state: State,
  sorting: Sorting
): Promise<Todos> => {
  const response = await axios.get(`todos/${state}?sorting={sorting}`)
  return response.data
}
```

This will certainly yield an error in our custom hook, where we call _fetchTodos_, so let's fix that:

```ts:title=useTodos-with-sorting {2, 4-5}
export const useTodos = () => {
  const { state, sorting } = useTodoParams()

  // üö® can you spot the mistake ‚¨áÔ∏è
  return useQuery(['todos', state], () => fetchTodo(state, sorting))
}
```

Maybe you've already spotted the issue: Our query key got out of sync with our actual dependencies, and no red squiggly lines are screaming at us about it üòî. In the above case, you'll likely spot the issue very fast (hopefully via an integration test), because changing the sorting does not automatically trigger a refetch. And, let's be honest, it's also pretty obvious in this simple example. I have however seen the query key diverge from the actual dependencies a couple of times in the last months, and with greater complexity, those can be some hard to track issues. There's also a reason why React comes with the [react-hooks/exhaustive-deps eslint rule](https://reactjs.org/docs/hooks-rules.html#eslint-plugin) to spot such issues.

So will React Query now come with its own eslint-rule?

Well, that would be one option. There is also the [babel-plugin-react-query-key-gen
](https://github.com/dominictwlee/babel-plugin-react-query-key-gen) that solves this problem by generating query keys for you, including all your dependencies. React Query however comes with a different, built-in way of making dependencies more explicit: The `QueryFunctionContext`.

### QueryFunctionContext

---

That's it for today. Feel free to reach out to me on [twitter](https://twitter.com/tkdodo)
if you have any questions, or just leave a comment below ‚¨áÔ∏è

<Comments withSeparator={false} />
