---
title: Advanced React Query
description:
date: 2021-03-06
banner: ../practical-react-query/react-query.png
tags:
    - react
    - react-query
---

import Comments from 'components/Comments'
import { Divider } from '@theme-ui/components'

<img src="../practical-react-query/react-query.png" />

<Divider />

-   [#1: Practical React Query](practical-react-query)
-   <b>#2: Advanced React Query</b>

<Divider />

Welcome to Part 2 of "Things I have to say about react-query". As I've become more and more involved with the library and the community around it, I've observed some more patterns people frequently ask about. Here is my take on them.

**Disclaimer**: If you've never worked with react-query, it doesn't make much sense to continue reading here. I'm not explaining any basic terms, so it might come across as confusing. If you want an introduction to the react-query basics, please read the [official docs](https://react-query.tanstack.com/overview) first, especially the Guides & Concepts section. Come back after that and read [#1: Practical React Query](practical-react-query) before continuing here :)

_Edit_: After writing this, I realized that I've taken a lot of time to cover _render optimizations_. So I wanted to point out, once again, that usually, for most apps, render optimizations probably don't matter as much as you'd think. Re-renders are a good thing. They make sure your app is up-to-date. I'd take an "unnecessary re-render" over a "missing render-that-should-have-been-there" all day every day. For more on this topic, please read:

-   [Fix the slow render before you fix the re-render](https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render) by Kent C. Dodds
-   [this article by @ryanflorence about premature optimizations](https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578)

### Data Transformation

Let's face it - most of us are _not_ using GraphQL. If you do, then you can most likely skip this section entirely, because you have the luxury of requesting your data in the format that you desire.

If you are working with REST though, you are constrained by what the backend returns. So how and where do you best transform data when working with react-query? The only answer worth a damn in software development applies here as well:

> It depends.

<p style="padding-left: 3rem; margin-top: -1rem">— Every developer, always</p>

Here are 3+1 approaches on where you _can_ transform data with their respective pros and cons.

#### 0. On the backend

This is my favourite approach, if you can afford it. If the backend returns data in exactly the structure we want, there is nothing we need to do. While this might sound unrealistic in many cases, e.g. when working with public REST APIs, it is also quite possible to achieve in enterprise applications. If you are in control of the backend and have an endpoint that returns data for your exact use-case, prefer to deliver the data the way you expect it.

🟢 &nbsp; no work on the frontend<br/>
🔴 &nbsp; not always possible

#### 1. In the queryFn

The _queryFn_ is the function that you pass to _useQuery_. It expects you to return a Promise, and the resulting data winds up in the query cache. But it doesn't mean that you have to absolutely return data in the structure that the backend delivers here. You can transform it before doing so:

```ts:title=queryFn-transformation
const fetchTodos = async (): Promise<Todos> => {
    const response = await axios.get('todos')
    const data: Todos = response.data

    return data.map((todo) => todo.name.toUpperCase())
}

export const useTodosQuery = () => useQuery(['todos'], fetchTodos)
```

On the frontend, you can then work with this data "as if it came like this from the backend". No where in your code will you actually work with todo names that are _not_ upper-cased. You will also _not_ have access to the original structure. If you look at the react-query-devtools, you will see the transformed structure. If you look at the network trace, you'll see the original structure. This might be confusing, so keep that in mind.

Also, there is no optimization that react-query can do for you here. Every time a fetch is executed, your transformation will run. If it's expensive, consider one of the other alternatives. Some companies also have a shared api layer that abstracts data fetching, so you might not have access to this layer to do your transformations.

🟢 &nbsp; very "close to the backend" in terms of co-location<br/>
🟡 &nbsp; the transformed structure winds up in the cache, so you don't have access to the original structure<br/>
🔴 &nbsp; runs on every fetch<br/>
🔴 &nbsp; not feasible if you have a shared api layer that you cannot freely modify

#### 2. In the render function

As advised in [Part 1](practical-react-query), if you create custom hooks, you can easily do transformations there:

```ts:title=render-transformation
const fetchTodos = async (): Promise<Todos> => {
    const response = await axios.get('todos')

    return response.data
}

export const useTodosQuery = () => {
    const queryInfo = useQuery(['todos'], fetchTodos)

    return {
        ...queryInfo,
        data: queryInfo.data?.map((todo) => todo.name.toUpperCase()),
    }
}
```

As it stands, this will not only run every time your fetch function runs, but actually on every render. Again, this is likely not a problem at all, but if it is, you can optimize with _useMemo_. Be careful to define your dependencies _as narrow as possible_. `data` returned by queryInfo will be referentially stable unless something really changed (in which case you want to recompute your transformation), but the `queryInfo` itself will _not_. If you add _queryInfo_ as your dependency, the transformation will again run on every render:

```ts:title=useMemo-dependencies
export const useTodosQuery = () => {
    const queryInfo = useQuery(['todos'], fetchTodos)

    return {
        ...queryInfo,
        // 🚨 don't do this - the useMemo does nothig at all here!
        data: React.useMemo(() => queryInfo.data?.map((todo) => todo.name.toUpperCase()), [
            queryInfo,
        ]),

        // ✅ correctly memoizes by queryInfo.data
        data: React.useMemo(() => queryInfo.data?.map((todo) => todo.name.toUpperCase()), [
            queryInfo.data,
        ]),
    }
}
```

Especially if you have additional logic in your custom hook to combine with your data transformation, this is a good option. Be aware that data can be potentially undefined, so use optional chaining when working with it.

🟢 &nbsp; optimizable via useMemo<br/>
🟡 &nbsp; exact structure cannot be inspected in the devtools<br/>
🔴 &nbsp; a bit more convoluted syntax<br/>
🔴 &nbsp; data can be potentially undefined<br/>

#### 3. using the select option

v3 introduced built-in selectors, which can also be used to transform data:

```ts:title=select-transformation
export const useTodosQuery = () =>
    useQuery(['todos'], fetchTodos, {
        select: (data) => data.map((todo) => todo.name.toUpperCase()),
    })
```

selectors will only be called if _data_ exists, so you don't have to care about _undefined_ here. Selectors like the one above will also run on every render, because the functional identity changes (it's an inline function). If your transformation is expensive, you can memoize it either with useCallback, or by extracting it to a stable function reference:

```ts:title=select-memoizations
const transformTodoNames = (data: Todos) => data.map((todo) => todo.name.toUpperCase())

export const useTodosQuery = () =>
    useQuery(['todos'], fetchTodos, {
        // ✅ uses a stable function reference
        select: transformTodoNames,
    })

export const useTodosQuery = () =>
    useQuery(['todos'], fetchTodos, {
        // ✅ memoizes with useCallback
        select: React.useCallback(
            (data: Todos) => data.map((todo) => todo.name.toUpperCase()),
            []
        ),
    })
```

Further, the select option can also be used to subscribe to only parts of the data. This is what makes this approach truly unique. Consider the following example:

```js:title=select-partial-subscriptions
export const useTodosQuery = (select) => useQuery(['todos'], fetchTodos, { select })

export const useTodosCount = () => useTodosQuery((data) => data.length)
export const useTodo = (id) => useTodosQuery((data) => data.find((todo) => todo.id === id))
```

Here, we've created a [useSelector](https://react-redux.js.org/api/hooks#useselector) like API by passing a custom selector to our _useTodosQuery_. The custom hooks still works like before, as _select_ will be _undefined_ if you don't pass it, so the whole state will be returned.

But if you pass a selector, you are now only subscribed to the result of the selector function. This is quite powerful, because it means that even if we update the name of a todo, our component that only subscribes to the count via _useTodosCount_ will _not_ rerender. The count hasn't changed, so react-query can bail out of rendering here 🥳.

🟢 &nbsp; best optimizations<br/>
🟢 &nbsp; allows for partial subscriptions<br/>
🟡 &nbsp; structure can be different for every observer<br/>
🟡 &nbsp; structual sharing is performed twice (read on for more info)

### Render optimizations

I've already written quite a bit about render optimizations when describing the select option. However, "Why does react-query re-render two times even though nothing changed in my data" is the question I probably needed to answer the most (apart from maybe: "Where can I find the v2 docs" 😅).

#### isFetching transition

I haven't been entirely honest in the above example when I said that this component will only re-render if the length of todos change:

```tsx:title=count-component

function TodosCount() {
    const todosCount = useTodosCount()

    return <div>{todosCount.data}</data>
}
```

Every time you make a background refetch, this component will re-render twice with the following query info:

```
{ status: 'success', data: [...], isFetching: true }
{ status: 'success', data: [...], isFetching: false }
```

That is because react-query exposes a lot of meta information for each query, and _isFetching_ is one of them. This flag will always be true when a request is in-flight. This is quite useful if you want to display a background loading indicator. But it's also kinda unnecessary if you don't do that.

#### notifyOnChangeProps

For this use-case, react-query has the _notifyOnChangeProps_ option. It can be set on a per-observer level to tell react-query: Please only inform this observer about changes if one of these props change. By setting this prop to `['data']`, we will find the optimized version we seek:

```ts:title=optimized-with-notifyOnChangeProps
export const useTodosQuery = (select, notifyOnChangeProps) =>
    useQuery(['todos'], fetchTodos, { select, notifyOnChangeProps })
export const useTodosCount = () => useTodosQuery((data) => data.length, ['data'])
```

You can see this in action in the [optimistic-updates-typescript](https://github.com/tannerlinsley/react-query/blob/master/examples/optimistic-updates-typescript/pages/index.tsx#L35-L48) example in the docs.

While he above code works well, it is a little bit troublesome and can get out-of-sync quite easily. What if we want to react to the _error_, too? Or we start to use the _isLoading_ flag? We have to keep the _notifyOnChangeProps_ list in-sync with whichever props we are actually using in our components. Is there a way to do this automatically? Turns out, there is:

#### Tracked Queries

I'm quite proud of this feature, given it's my first major contribution to the library. If you set _notifyOnChangeProps_ to `'tracked'`, react-query will keep track of the props you are using during render, and will use this to compute the list. This will optimize exactly the same way as specifying the list manually, except that you don't have to think about it. You can also turn this on globally for all your queries:

```tsx:title=tracked-queries
const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            notifyOnChangeProps: 'tracked',
        },
    },
})
function App() {
    return (
        <QueryClientProvider client={queryClient}>
            <Example />
        </QueryClientProvider>
    )
}
```

There are some limitations to tracked queries, which is why this is an opt-in feature:

-   If you use rest spread during destructuring, you are effectively observing all properties. Normal destructuring is fine, just don't do this:

```ts:title=problematic-rest-spread
// 🚨 will track all properties
const { isLoading, ...queryInfo } = useQuery(...)

// ✅ this is totally fine
const { isLoading, data } = useQuery(...)
```

-   Tracked queries only work "during render". If you only access properties during effects, they will not be tracked. This is quite the edge case though because of dependency arrays:

```ts:title=tracking-effects
const queryInfo = useQuery(...)

// 🚨 will not corectly track data
React.useEffect(() => {
    console.log(queryInfo.data)
})

// ✅ fine because the dependency array is accessed during render
React.useEffect(() => {
    console.log(queryInfo.data)
}, [queryInfo.data])
```

-   Tracked queries don't reset on each render, so if you track a field once, you'll track it for the lifetime of the observer:

```ts:title=no-reset
const queryInfo = useQuery(...)

if (someCondition()) {
    // 🟡 we will track the data prop if someCondition was true in any previous render cycle
    return <div>{queryInfo.data}</div>
}
```

If you think this is complicated stuff - I think you're right. But hey, this is "advanced react-query" after all 😜.

#### Structural sharing

A different, but no less important render optimization that react-query has turned on out of the box is _structural sharing_. This feature makes sure that we keep referential identity of our _data_ on every level. As an example, suppose you have the following structure:

```json
[
    { "id": 1, "name": "Learn React", "status": "active" },
    { "id": 2, "name": "Learn react-query", "status": "todo" }
]
```

No suppose we transition our first todo into the _done_ state, and we make a background refetch. We'll get a completely new json from our backend:

```diff
[
-    { "id": 1, "name": "Learn React", "status": "active" },
+    { "id": 1, "name": "Learn React", "status": "done" },
    { "id": 2, "name": "Learn react-query", "status": "todo" }
]
```

Now react-query will attempt to compare the old state and the new and keep as much of the previous state as possible. In our example, the todos array will be new, because we updated a todo. The object with id 1 will also be new, but the object for id 2 will be the same reference as the one in the previous state - react-query will just copy it over to the new result because nothing has changed in it.

This comes in very handy when using selectors for partial subscriptions:

```ts:title=optimized-selectors
// ✅ will only re-render if _something_ within todo with id:2 changes
// thanks to structural sharing
const { data } = useTodo(2)
```

As I've hinted before, for selectors, structural sharing will be done twice: Once on the result returned from the queryFn to determine if anything changed at all, and then once more on the _result_ of the selector function. In some instances, especially when having very large datasets, structural sharing _can_ be a bottleneck. It also only works on json-serializable data. If you don't need this optimization, you can turn it off by setting _structuralSharing: false_ on any query.

Have a look at the [replaceEqualDeep tests](https://github.com/tannerlinsley/react-query/blob/80cecef22c3e088d6cd9f8fbc5cd9e2c0aab962f/src/core/tests/utils.test.tsx#L97-L304) if you want to learn more about what happens under the hood.

### Status check order

Most examples look something like this:

```jsx:title=simple-example
const todos = useTodos()

if (todos.isLoading) return 'Loading...'
if (todos.error) return 'An error has occurred: ' + error.message

return <div>{todos.data.map(renderTodo)}</div>
```

Here, we check for loading and error first, and then display our data. This is probably fine for some use-cases, but not for others.

#### Background errors

In many situations, if a background refetch fails, it could be silently ignored. But the code above does not do that. Suppose the initial fetch succeeds, and we render our data. Now the user switches tabs, and they come back some minutes later. React-Query will do a background refetch, which fails. In this case, react-query will be in the following state:

```json
{ "status": "error", "error": "Something went wrong", "data": [{ ... }] }
```

As you can see, we will have _both_ an error _and_ the stale data available. Now it's up to us to decide what we display. Is it important to show the error? Is it enough to show the stale data only, if we have any? Should we show both?

There is no clear answer to this question - it depends on your exact use-case. But if you prefer displaying data when you have any in the cache, check for data-availability first:

```jsx:title=data-first
const todos = useTodos()

if (todos.data) {
    return <div>{todos.data.map(renderTodo)}</div>
}
if (todos.error) return 'An error has occurred: ' + error.message

return 'Loading...'
```

### Type Inference and Type Narrowing

<Comments>Leave a comment below ⬇️</Comments>
```
