---
title: Testing React Query
description:
date: 2021-04-03
banner: ./testing.jpeg
tags:
    - react
    - react-query
    - JavaScript
    - TypeScript
---

import Comments from 'components/Comments'
import Attribution from 'components/Attribution'
import { Divider } from '@theme-ui/components'

<img src="./testing.jpeg" />

<Attribution name="Girl with red hat" url="https://unsplash.com/@girlwithredhat" />

-   [#1: Practical React Query](practical-react-query)
-   [#2: React Query Data Transformations](react-query-data-transformations)
-   [#3: React Query Render Optimizations](react-query-render-optimizations)
-   [#4: Status Checks in React Query](status-checks-in-react-query)
-   <b>#5: Testing React Query</b>

<Divider />

Questions around the testing topic come up quite often together with React Query, so I'll try to answer some of them here. I think one reason for that is that testing "smart" components (also called [container components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)) is not the easiest thing to do. With the rise of hooks, this split has been largely deprecated. So we now have much more components that consume dependencies outside of "just props".

They might useContext. They might useSelector. Or they might useQuery.

Those components are technically speaking no longer pure, because calling them in different environments leads to different results. When testing them, you need to carefully setup those surrounding environments to get things working.

### Mocking network requests

Since React Query is an async server state management library, your components will likely make requests to a backend. Of course, when testing, this backend is not available to actually deliver data.

There are tons of articles out there on how to mock data with jest. You can mock your api client if you have one. You can mock fetch or axios directly. I can only second what Kent C. Dodds has written in his article [Stop mocking fetch](https://kentcdodds.com/blog/stop-mocking-fetch):

Use [mock service worker](https://mswjs.io/) by [@ApiMocking](https://twitter.com/ApiMocking)

It can be your single source of truth when it comes mocking your apis:

-   works in node for testing
-   supports REST and GraphQL
-   has a [storybook addon](https://storybook.js.org/addons/msw-storybook-addon) so you can write stories for your components that _useQuery_
-   works in the browser for development purposes, and you'll still see the requests going out in the browser devtools
-   works with cypress, similar to fixtures

<Divider />

With our network layer being taken care of, we can start talking about React Query specific things to keep an eye on:

### QueryClientProvider

Whenever you use React Query, you need a QueryClientProvider and give it a queryClient - a vessel which holds the _QueryCache_. The cache will in turn hold the data of your queries. Some tutorials suggest creating one QueryClient and resetting it after each test, but I think that shared state during tests is not a good idea at all. What if tests run in parallel? You might get unexpected results and flaky tests with this approach.

I do prefer to give each test it's own QueryClientProvider, and create a _new QueryCache_ for each test. That way, tests are completely isolated from each other.

#### For custom hooks

If you are testing custom hooks, I'm quite certain you're using [react-hooks-testing-library](https://react-hooks-testing-library.com/). It's the easiest thing there is to test hooks. With that library, we can wrap our hook in a [wrapper](https://react-hooks-testing-library.com/reference/api#wrapper), which is a React component to wrap the test component in when rendering. I think this is the perfect place to create the QueryClient, because it will be executed once per test:

```tsx:title=wrapper
const createWrapper = () => {
    // ✅ creates a new QueryClient for each test
    const queryClient = new QueryClient()
    return ({ children }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    )
}

test("my first test", async () => {
    const { result } = renderHook(() => useCustomHook(), {
        wrapper: createWrapper()
    })
}
```

#### For components

If you want to test a Component that uses a _useQuery_ hook, you also need to wrap that Component in QueryClientProvider. A shallow wrapper around _render_ from [react-testing-library](https://testing-library.com/docs/react-testing-library/intro/) seems like a good choice. Have a look at how React Query does it [internally for their tests](https://github.com/tannerlinsley/react-query/blob/ead2e5dd5237f3d004b66316b5f36af718286d2d/src/react/tests/utils.tsx#L6-L17).

### Turn off retries

It's one of the most common "gotchas" with React Query and testing: The library defaults to three retries with exponential backoff, which means that your tests are likely to timeout if you want to test an erroneous query. The easiest way to to this is, again, in the QueryClientProvider. Let's extend the above example:

```tsx:title=no-retires {2-8}
const createWrapper = () => {
    const queryClient = new QueryClient({
        defaultOptions: {
            queries: {
                // ✅ turns retries off
                retry: false,
            },
        },
    })

    return ({ children }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    )
}

test("my first test", async () => {
    const { result } = renderHook(() => useCustomHook(), {
        wrapper: createWrapper()
    })
}
```

This will set the defaults for all queries in the component tree to "no retries". It is important to know that this will only work if your actual _useQuery_ has no explicit retries set. If you have a query that wants 5 retries, this will still take precedence, because defaults are only taken as a fallback.

The best advice I can give you for this problem is: Don't set these options on _useQuery_ directly. Try to use and override the defaults as much as possible, and if you really need to change something for specific queries, use [queryClient.setQueryDefaults](https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults). For example:

```tsx:title=setQueryDefaults
const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            retry: 2,
        },
    },
})

// ✅ only todos will retry 5 times
queryClient.setQueryDefaults('todos', { retry: 5 })

function App() {
    return (
        <QueryClientProvider client={queryClient}>
            <Example />
        </QueryClientProvider>
    )
}
```

Here, all queries will retry two times, only _todos_ will retry five times, and I still have the option to turn it off for all queries in my tests.

#### ReactQueryConfigProvider

Of course, this only works for known query keys. Sometimes, you really want to set some configs on a subset of your component tree. In v2, React Query had a [ReactQueryConfigProvider](https://react-query-v2.tanstack.com/docs/api#reactqueryconfigprovider) for that exact use-case. You can achieve the same thing in v3 with a couple of lines of codes:

```jsx:title=ReactQueryConfigProvider
const ReactQueryConfigProvider = ({ children, defaultOptions }) => {
    const client = useQueryClient()
    const [newClient] = React.useState(
        () =>
            new QueryClient({
                queryCache: client.getQueryCache(),
                muationCache: client.getMutationCache(),
                defaultOptions,
            })
    )

    return <QueryClientProvider client={newClient}>{children}</QueryClientProvider>
}
```

You can see this in action in this [codesandbox example](https://codesandbox.io/s/react-query-config-provider-v3-lt00f).

<Divider />

Feel free to reach out to me on [twitter](https://twitter.com/tkdodo)
if you have any questions, or just leave a comment below ⬇️

<Comments withSeparator={false} />
