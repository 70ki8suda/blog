---
title: Avoiding legacy systems
description:
date: 2020-11-01
banner: ./swiss-knife.png
tags:
    - principles
    - documentation
    - git
    - z-index
---

import Comments from 'components/Comments'
import { Divider } from '@theme-ui/components'

<img src="./legacy.jpg" />

<Attribution name="Sergiu VƒÉlena»ô" url="https://unsplash.com/@svalenas" />

No one likes working with legacy software.
They are hard to maintain.
They are not fun to work with.
Every bug report you get, you feel like: "Oh god please no"!
You don't want to touch _anything_ there.
Adding features? Haven't dared to do that for a long time, because you don't know what will break if you do.

> Never touch a running system

> If it ain't broke, don't fix it

Famous quotes every developer knows, because legacy software is _everywhere_.

### What is legacy software?

We rarely get the chance to bootstrap something from scratch.
Something brand new. A green field.
A place where we will never make the mistakes of the past again.

Except that we will.

Every software project started out on a green field once, where the architects had the best of intentions.
Since no one likes legacy systems, no one creates them on purpose.

They usually derive from incidental complexity, time constraints and shortcuts that we take because we have to.
We are not proud of that code, but it fixes the bug, so let's ship it.
Yes, the customer really wanted that feature, and it needed to be done yesterday (my favourite deadline),
so let's please just make it "quick and dirty" and "refactor it later".

Of course, later is just an anagram for never.

We add a `todo` in the code, or we create a follow-up issue in our favourite backlog,
which already has 500+ issues no one ever looks at.

The second part which contributes to most legacy systems is _feature creep_.
Over time, we add more and more features no one could possibly forsee at the beginning.
With every feature added, it gets harder and harder to maintain the code base,
until at one point you add feature X and break something completely unrelated.

It doesn't necessarily take years for a product to become legacy software (by the above standards).
It's totally possible for a startup to manage that in a couple of months.

### What can we developers do against it?

I concur that some decisions are just out of our hands.
The sales department has already sold the feature to the customer, and it has to be finished by the end of the month.
Bummer.
If situations like these are the norm rather than the exception, it shows categorical mismanagement.
Some companies just don't care, some managers just don't see the benefit of investing in quality now and rather pay the price later.

Personally, I constantly try to talk people out of features.
To me, it is not the duty of developers to "produce features" or even "write code".
Our job is to produce quality.
If that means deleting code, all the better - fewer lines of code to maintain are always a win.
There are enough other involved parties eager to get developers to add features, so I am more reluctant about it.

When it comes to what we _can do_ to avoid legacy software, there is obviously no easy answer.
It's a complex topic that you cannot solve with one simple trick.
There is however one thing that I always put emphasis on when it comes to this topic:

### Documentation

Generally speaking, we don't document enough, and if we do, it tends to be the wrong things that get documented.
People focus a lot on the _WHAT_. What does this function do? What is its interface?
This code block here looks complicated, so I better write a comment to explain what it does.

The truth is, the _WHAT_ can almost always be figured out by someone reading the code.
If we cannot figure out what a code is doing, there is probably something wrong with it.
I understand that it might not always be obvious, so here are four things that can help document the _WHAT_:

#### 1. Naming

Naming is hard. Naming is subjective.
Yet I believe that extracting objectively complex code (code where people often ask: _WHAT_ is this even doing?)
to a separate function with a name that explains _WHAT_ is going on, or even into multiple functions if necessary,
is going to help a lot. I will probably write a separate blog post about this topic.

This will also help with the second suggestion:

#### 2. Tests

I don't like (writing) tests. There, I said it. Never have, probably never will.
But I do understand the value of good tests.

They will give you the confidence to touch existing code, without the fear of breaking anything,
which is one of the most feared traits of legacy systems: Nobody dares to touch anything.

Second of all, tests can also be seen as documentation.
By looking at the tests, you can see all the cases the developer who wrote the code thought about at the time of writing.
This doesn't mean that tests are exhaustive, almost no one has 100% branch coverage.
Usually, when a bug emerges, people write another test case, which is good, because it adds more documentation.

#### 3. Use a statically typed language

Static type checkers will not only give you confidence when touching / refactoring existing code,
they also help to document function interfaces.
When looking at a function for the first time, it helps tremendously to know what can be put into a function and
what the expected return value is.

#### 4. Comments

> Good code needs to be self-documenting

Well, no.
Using good names, strong types and a good amount of tests go a long way, but it does _not_ replace the need for writing comments,
though we need to ask the right question when we talk about comments.

### _WHY_

As I said before, I think people focus too much on documenting the _WHAT_, even though that is rarely the problem.
It might take a developer some time to debug complex code, but they will eventually figure out what is going on,
and the techniques above will make finding that out even easier.

The one thing that is very hard to find out is the _WHY_. _WHY_ are we even doing this?
And this is way more subtle than documenting what a function / a module / an if branch does.
It's the little things that will often give us a headache:

-   _WHY_ the early return in that function?
-   _WHY_ do we need an extra negative margin here??
-   _WHY_ z-index: 999 ???

What was the intent of the developer who wrote that code when they wrote that code?
Usually, you can't tell. I rarely know _WHY_ I did something the way I did it a couple of weeks later,
unless I write it down immediately.

If you are lucky, you can track a change back to an issue or a PR, and you have more information there.
But sometimes, you just don't.
Even if you do, the PR that added that feature will likely not tell you _WHY_ we had to add z-index: 999... ü§∑‚Äç‚ôÇÔ∏è

Unless of course, you added a comment that explains your intent.

_We need the z-index to be 999 so that our Modal stays above the BannerMessages that we also display on the Dashboard in case the user has not yet subscribed to our newsletter. Also, it conflicts with the CookieNotice if we keep the value any lower._

Thank you, thoughtful developer. Now I know!
And now that I know, I will have more confidence touching this part of the code.

#### Comments in code



<Comments>
    How do you prefer to document your code? Let me know in the comments below ‚¨áÔ∏è
</Comments>
