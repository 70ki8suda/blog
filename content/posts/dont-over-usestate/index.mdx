---
title: Don't over useState
description: Avoid using state too often - lots of things aren't even state at all...
date: 2020-08-29
banner: ./use-state-pitfalls.png
tags:
    - React
    - useState pitfalls
---

`useState` is considered to be the most basic of all the hooks provided by React.
It is also the one you are most likely to use (no pun intended), alongside `useEffect`.

Yet over the last couple of months, I have seen this hook being misused a lot.
This has mostly nothing to do with the hook itself, but because state management is never easy.

This is the first part of a series I'm calling _useState pitfalls_,
where I will try to outline common scenarios with the useState hook that might better be solved differently.

### What is state?

I think it all boils down to understanding what state is.
Or more precisely, what state _isn't_.
To comprehend this, we have to look no further than
[the official react docs](https://reactjs.org/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state):

> Ask three questions about each piece of data:

> Is it passed in from a parent via props? If so, it probably isn’t state.
> Does it remain unchanged over time? If so, it probably isn’t state.
> Can you compute it based on any other state or props in your component? If so, it isn’t state.

So far, so easy. Putting _props to state_ (1) is a whole other topic I will probably write about another time,
and if you are not using the setter (2), then it it probably pretty obvious that we are _not_ dealing with state.

That leaves the third question: _derived state_.
It might seem pretty apparent that a value that can be computed from a state value is _not_ it's own state.
However, when I reviewed some code challenges for a client of mine lately, this is exactly the pattern I have seen a lot,
even from senior candidates.

### An example

The exercise is pretty simple and goes something like this:
Fetch some data from a remote endpoint (a list of items with categories) and let the user filter by the category.

The way the state was managed mostly was something like this:

```jsx:title=use-state
import { fetchData } from 'api'
import { getCategoriesFromData } from 'utils'

const App = () => {
    const [data, setData] = React.useState(null)
    const [categories, setCategories] = React.useState([])

    React.useEffect(() => {
        async function fetch() {
            const response = await fetchData()
            setData(response.data)
        }

        fetch()
    }, [getRemoteData])

    React.useEffect(() => {
        if (data) {
            setCategories(getCategoriesFromData(data))
        }
    }, [data, getCategoriesFromData])

    return <>...</>
}
```

At first glance, this looks okay. You might be thinking:
We have an effect that fetches the data for us, and another effect that keeps the categories _in sync_ with the data.
This is exactly what the useEffect hook is for (keeping things in sync), so what is bad about this approach?

### Getting out of sync

This will actually work fine, and it's also not totally unreadable or hard to reason about.
The problem is that we have a "publicly" available function `setCategories` that future developers might use.

If we intended our categories to be solely dependent on our data (like we expressed with our useEffect), this is bad news:

```jsx:title=bad-news {2, 26}
import { fetchData } from 'api'
import { getCategoriesFromData, getMoreCategories } from 'utils'

const App = () => {
    const [data, setData] = React.useState(null)
    const [categories, setCategories] = React.useState([])

    React.useEffect(() => {
        async function fetch() {
            const response = await fetchData()
            setData(response.data)
        }

        fetch()
    }, [getRemoteData])

    React.useEffect(() => {
        if (data) {
            setCategories(getCategoriesFromData(data))
        }
    }, [data, getCategoriesFromData])

    return (
        <>
            ...
            <Button onClick={() => setCategories(getMoreCategories())}>Get more</Button>
        </>
    )
}
```

Now what? We have no predictable way of telling what "categories" are.

-   Your page loads, categories are _X_
-   You click the button, categories are _Y_
-   If your data fetching re-executes, say, because you are using [react-query](https://react-query.tanstack.com/),
    which has features like automatic re-fetching when you focus your tab or when you re-connect to your network
    (it's awesome, you should give it a try), your categories will be _X_ again.

Inadvertently, we have now introduced a hard to track bug that will only occur every now and then.

