---
title: Syncing props to useState
description:
date: 2020-10-15
banner: ../dont-over-usestate/use-state-pitfalls.png
tags:
    - React
    - useState pitfalls
---

import Comments from 'components/Comments'
import { Divider } from '@theme-ui/components'

<img src="../dont-over-usestate/use-state-pitfalls.png" />

<Divider />

In the [first part](dont-over-use-state) of the useState pitfalls series,
I talked about avoiding state all together for derived state.

This part is about a common scenario, where we want to initialize our state with values we get as props.
This is something we probably do a lot, and it's not per-se wrong, but it has some potential issues that we need to be aware of.

### The example

I will use a classic list / detail use-case as example.
We have a list of users, and selecting one of them will result in a detail form being filled.
We want to show the users' email address in the detail form, and also have an apply button that will update that data.

It's an interactive example, so feel free to click around (the code is also editable 🚀):

```js react-live
const users = [
    {
        id: 1,
        name: 'Dominik',
        email: 'dominik@dorfmeister.cc',
    },
    {
        id: 2,
        name: 'John',
        email: 'john@doe.com',
    },
]

function App() {
    const [selected, setSelected] = React.useState(users[0])

    return (
        <div>
            {users.map((user) => (
                <button type="button" key={user.id} onClick={() => setSelected(user)}>
                    {user.id === selected.id ? user.name.toUpperCase() : user.name}
                </button>
            ))}
            <DetailView email={selected.email} />
        </div>
    )
}

function DetailView({ initialEmail }) {
    const [email, setEmail] = React.useState(initialEmail)

    return (
        <div>
            <input
                type="text"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
            />
            <button type="button" onClick={() => alert(email)}>
                Apply
            </button>
        </div>
    )
}

render(<App />)
```

### useState initial value

You might notice right away that the example is _not_ working.
You can edit the email address and click _Apply_, but if you click on _John_, the input field will not update.

As much as React wants us to [think in hooks](https://wattenberger.com/blog/react-hooks) rather than in lifecycles,
when it comes to state, there is a big difference between the first render (also known as _mount_) and further renders
(better known as re-renders).

The initial value of a useState hook is always _discarded_ on re-renders - it only has an effect when the component _mounts_.

When you click on _John_, the DetailView component will be re-rendered (because it already exists on the screen),
which means that John's email will not be put into our state.
Bummer, because we still need the local state to edit the email address (to keep the draft changes).
We don't want to update the user Array directly, because we might never click Apply.

I know three ways to handle this and similar use-cases:

### Artificially re-mount the component

Whoops, this sounds bad, but it's not what you might think. Think more about _Modals_.

Showing the DetailView in a _Modal_ will magically make our code above work, because Modals are usually rendered conditionally.
When we click on _John_, we mount a Modal, thus the useState initial value will be respected.
When the user closes the Modal, it will be _unmounted_, and the next time a user is selected it will be _mounted_ again.

Here is how that might look:

```js react-live
const users = [
    {
        id: 1,
        name: 'Dominik',
        email: 'dominik@dorfmeister.cc',
    },
    {
        id: 2,
        name: 'John',
        email: 'john@doe.com',
    },
]

function App() {
    const [selected, setSelected] = React.useState()

    const close = () => setSelected(undefined)

    return (
        <div>
            {users.map((user) => (
                <button type="button" key={user.id} onClick={() => setSelected(user)}>
                    {user.name}
                </button>
            ))}
            {selected && (
                <div
                    style={{
                        position: 'fixed',
                        top: '0',
                        left: '0',
                        paddingTop: '100px',
                        width: '100%',
                        height: '100%',
                        backgroundColor: 'rgba(0,0,0,0.4)',
                    }}
                >
                    <div
                        style={{
                            display: 'flex',
                            justifyContent: 'center',
                            width: '80%',
                            height: '50vh',
                            margin: 'auto',
                            backgroundColor: 'white',
                        }}
                    >
                        <DetailView email={selected.email} close={close} />
                        <span style={{ cursor: 'pointer' }} onClick={close}>
                            &times;
                        </span>
                    </div>
                </div>
            )}
        </div>
    )
}

function DetailView({ initialEmail, close }) {
    const [email, setEmail] = React.useState(initialEmail)

    return (
        <div>
            <input
                type="text"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
            />
            <button
                type="button"
                onClick={() => {
                    alert(email)
                    close()
                }}
            >
                Apply
            </button>
        </div>
    )
}

render(<App />)
```

Excuse my css, I suck at this part of web development 😅

But the example works now. That is because the Modal conditionally renders our DetailView, which will make it mount again.

I'm sure many of you have done that a lot, and it's a valid solution.
But be aware that this only works because you are rendering the DetailView in the Modal.
If you want the DetailView to be renderable everywhere, we would need a different solution.

### Lifting state up

You've probably heard this phrase before, the official React docs also have [a section on that topic](https://reactjs.org/docs/lifting-state-up.html).

For this example, it basically just means to take the draft state and move it further up the tree,
thus making our DetailView a fully controlled component.
Since the DetailView then doesn't need any local state at all, we won't have the problem of putting props into state.

```js react-live
const users = [
    {
        id: 1,
        name: 'Dominik',
        email: 'dominik@dorfmeister.cc',
    },
    {
        id: 2,
        name: 'John',
        email: 'john@doe.com',
    },
]

function App() {
    const [selected, setSelected] = React.useState(users[0])
    const [email, setEmail] = React.useState(selected.email)

    return (
        <div>
            {users.map((user) => (
                <button
                    type="button"
                    key={user.id}
                    onClick={() => {
                        setSelected(user)
                        setEmail(user.email)
                    }}
                >
                    {user.id === selected.id ? user.name.toUpperCase() : user.name}
                </button>
            ))}
            <DetailView email={email} setEmail={setEmail} />
        </div>
    )
}

function DetailView({ email, setEmail }) {
    return (
        <div>
            <input
                type="text"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
            />
            <button type="button" onClick={() => alert(email)}>
                Apply
            </button>
        </div>
    )
}

render(<App />)
```

Now, the App has full control over all the state, and the DetailView is just a so-called "dummy" component.
This approach is feasible for many use-cases, but it's not without drawbacks.

Typing in the input field will now re-render the whole App with every key-stroke.
While this is not a problem for this small example, it might be a problem for bigger Apps.
People often resort to global state managers because they promise to re-render efficiently.

Once could also argue that the scope of the draft email state is too big.
Why does the App even care about that, it probably only cares about it once the user hits Apply.

The third approach is kind of the middle ground between the two:
Keep the same ux but still re-mount your form when you need to.

### Fully uncontrolled with a key

```js react-live
const users = [
    {
        id: 1,
        name: 'Dominik',
        email: 'dominik@dorfmeister.cc',
    },
    {
        id: 2,
        name: 'John',
        email: 'john@doe.com',
    },
]

function App() {
    const [selected, setSelected] = React.useState(users[0])

    return (
        <div>
            {users.map((user) => (
                <button type="button" key={user.id} onClick={() => setSelected(user)}>
                    {user.id === selected.id ? user.name.toUpperCase() : user.name}
                </button>
            ))}
            <DetailView key={selected.id} email={selected.email} />
        </div>
    )
}

function DetailView({ initialEmail }) {
    const [email, setEmail] = React.useState(initialEmail)

    return (
        <div>
            <input
                type="text"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
            />
            <button type="button" onClick={() => alert(email)}>
                Apply
            </button>
        </div>
    )
}

render(<App />)
```

This is exactly like the first example, with just one minor change:

```diff
- <DetailView email={selected.email} />
+ <DetailView key={selected.id} email={selected.email} />
```

#### React keys

The `key` attribute on a React component is a special thing.
Keys are mostly used for lists to signalise stability to React,
so that the Reconciler knows which elements can be re-used, and thus re-rendered.

However, you can also just put a key attribute on any component to tell React:
"Please mount this whenever the key changes. As long as the key is the same, please re-render".

This can be seen a little bit like the dependency array in effects.
If it changes, compared to the previous render, React will re-run the "mounting" of the component.

If you want to know more, please read this [in-depth explanation about why keys are necessary](https://reactjs.org/docs/reconciliation.html#recursing-on-children)

### The non-solution

You might be tempted to solve the problem with an effect that "syncs" the props to the state:

```ts:title=syncing-props-and-state
function DetailView({ initialEmail }) {
    const [email, setEmail] = React.useState(initialEmail)

    React.useEffect(() => {
        setEmail(initialEmail)
    }, [initialEmail])

    return (...)
}

```

I would consider effects like this generally an anti-pattern.
Effects should be used to sync React state with something _outside_ of React, e.g. with localstorage.

But here, we are syncing something that already lives inside React with React state.
Further, the condition on which we sync does not really reflect what we want to achive:
We want to reset the state whenever another user is selected.

The first solution does this via conditional rendering,
the second one by setting the state explicitly when the button that selects a user is clicked,
and the third one by providing a stable key (the user id).

Emails might be a weird example, because they are generally also unique,
but what if two users have the same data (e.g. a firstName)?
The effect won't re-run, even though we click on a different user, and thus the draft state stays the same.

Similarly, what if the data changes in the parent component
(e.g. because of a re-fetch by [react-query](https://react-query.tanstack.com/docs/guides/window-focus-refetching)),
but our user has already changed the value in the input field?
Would we really want to override the user input in these cases?

So, effects like these open you up to a bunch of hard-to-track errors in corner cases that you'd better avoid.

### Takeaways

I don't have a preferred solution, I have used all three approaches occasionally.
The detail view owning the draft state has some advantages, but unmounting comes with a bit of a cost.
Lifting state up also has advantages, as fully controlled components are easy to reason about.

<Comments>Leave a comment below ⬇️</Comments>
```
