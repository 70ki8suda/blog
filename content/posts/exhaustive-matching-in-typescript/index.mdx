---
title: Exhaustive matching in Typescript
date: 2020-08-09
tags:
    - Scala
    - Typescript
    - React
---

It is already well known in the frontend development community that adopting Typescript is a good idea for (almost) every project that reaches a certain size.
Advantages cited usually evolve around safety, clearly documented interface, finding errors before they go to production and being able to refactor safely.

While I totally agree that these are great points in favor of Typescript, I think there is one advantage that is criminally underrated:

### The ability to safely add code

Even though I firmly believe that deleting code is much more fun (and productive) than writing code, what we do most of the time, is adding code.

Adding features. Adding enhancements to existing features. Adding xyz. After all, it is mostly what customers want.
So how come we never talk about how great typescript is, if used correctly, for _adding_ things.

Yes, moving and renaming things and having the compiler tell you where you forgot something is great,
but IDEs are catching up and pretty good at these things for JavaScript files already.
But no Editor will tell you that you forgot to handle a new branch in your switch statement when you add a new feature.

This is where exhaustive matching comes into play.

### What is exhaustive matching

Some languages, like `OCaml`, `F#` or `Scala` support the concept of _pattern matching_.
It's a little bit like javascript's switch statement on steroids, as it allows matching a value not only against other values, but also against patterns.

Exhaustive matching basically means that the compiler, given that he knows all the possible states,
can tell you when you are missing one state in your match.
I will use `scala` code for the examples since it's the language I am most familiar with.

```java:title=basic-pattern-matching-in-scala
sealed trait Shape

final case class Circle(radius: Int) extends Shape
final case class Rectangle(width: Int, height: Int) extends Shape

def renderShape(shape: Shape): String = {
  shape match {
    case _:Rectangle => "I am a Rectangle!"
  }
}
```

[Try me in scastie](https://scastie.scala-lang.org/8asQjmtsSTuK2FKgmEX65w)

Here, the compiler would complain with the following message:

> match may not be exhaustive. It would fail on the following input: Circle

Great, so as a JavaScript developer, being aware of the [default-case](https://eslint.org/docs/rules/default-case) eslint rule,
I'll just add a default case here and call it a day:

```java:title=default-case {4}"
def renderShape(shape: Shape): String = {
  shape match {
    case _:Rectangle => "I am a Rectangle!"
    case _ => "I'm a Circle"
  }
}
```

[Try me in scastie](https://scastie.scala-lang.org/eBVdb1hIR46nLDqwuzPeeg)

The program works, and all the cases in the match are being taken care of, so no one complains.
But what happens if we add another shape?

```java:title=a-new-shape {1}"
final case class Square(length: Int) extends Shape

def renderShape(shape: Shape): String = {
  shape match {
    case _:Rectangle => "I am a Rectangle!"
    case _ => "I'm a Circle"
  }
}

```

[Try me in scastie](https://scastie.scala-lang.org/gPHbnUrpTgyK0arINPP2cg)

Right. The program will still work, but it will not work correctly. If we pass a `Square` to the `renderShape` method,
it will identify as a `Circle`, which is certainly not what we would expect.

Sure, as long as the code is [co-located](https://kentcdodds.com/blog/colocation), this might be a non-issue.
You will see that you have to adapt the code right below.

But obviously, in a fairly large code base, you will have go to through all the usages, and it's easy to forget one.
Being able to utilize _compiler driven development_ (think: Fix everything that's red and then it is guaranteed to work) is of great help.

So here is how the fixed scala code would look:

```java:title=exhaustive-match {4,5}"
def renderShape(shape: Shape): String = {
  shape match {
    case _:Rectangle => "I am a Rectangle!"
    case _:Circle => "I'm a Circle"
    case _:Square => "I'm a Square"
  }
}

```

[Try me in scastie](https://scastie.scala-lang.org/KinShmJ1R3GyxyBR5POWSQ)

Notice how we just got rid of the default case completely.
If we add a `Triangle` now, it will show us an error again.

### How can we do this in Typescript

This is great and all, but `Typescript` doesn't support pattern matching, so how are we supposed to do this in TS?

It turns out the Typescript compiler is actually pretty smart when it comes to matching exhaustively on union types.
This is best done with tagged unions, which just means a union where each member define a discriminator of a literal type:

```ts:title=tagged-union
type Circle = {
    kind: 'circle'
    radius: number
}

type Rectangle = {
    kind: 'rectangle'
    width: number
    height: number
}

type Shape = Circle | Rectangle

const renderShape = (shape: Shape): string => {
    switch (shape.kind) {
        case 'circle':
            return 'I am a circle'
    }
}
```

[Typescript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAwglgJwMYBtoF4oG8BQV9QDWcAdgCYBcUA5EoqhNXgQgIZlwCuAzlSZwFsARhAQ4AvjlCQoAJQhJgrEgHM0UTLgJFSlGggVLVaJtoDucMsAAWfQSLHbrEOCuvA7w0RKnhoAZWtWGUx4ZHUAHzlDZTUIHBwkAHsSbmAoA3JRQOCMKAAKbiDIKhzIAEoqNIRSFQ0APmxmfG4LYCRrAqLcgDpicnKm7W0kVm5oWnoTCmbh7QNgTgQSGgBJKFYBDag6cMZZyXEgA)

In this example, the `kind` field serves as the discriminator: Every shape is uniquely identified by it.

With the above code, you should now see the following error:

> Function lacks ending return statement and return type does not include 'undefined'.(2366)

Note that even if you remove the explicit return type,
and if you have [noImplicitReturns](https://www.typescriptlang.org/tsconfig#noImplicitReturns) turned on in your `tsconfig.json`,
you will _still_ get the error:

> Not all code paths return a value.(7030)

So the compiler _really_ wants to tell us that we forgot something here, which is great.

Again, we should _not_ fall into the trap of adding a `default` case here.
I would even disable the aforementioned eslint rule for Typescript files, because I don't think it adds a lot that the compiler won't catch for us anyways.

The compiler will also narrow the type for us in the `case` block, so we _will_ have access to `shape.radius` inside the `case 'circle'`, but not outside of it.

A small caveat seems to be that you cannot use object destructuring on the shape param.
Even though all members of the union type contain a shape, Typescript won't accept this:

```ts:title=no-destructuring {1, 4}
const renderShape = ({ kind, ...shape }: Shape): string => {
    switch (kind) {
        case 'circle':
            return `I am a circle with ${shape.radius}`
    }
}
```

[Typescript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAwglgJwMYBtoF4oG8BQV9QDWcAdgCYBcUA5EoqhNXgQgIZlwCuAzlSZwFsARhAQ4AvjlCQoAJQhJgrEgHM0UTLgJFSlGggVLVaJtoDucMsAAWfQSLHbrEOCuvA7w0RKnhoAZWtWGUx4ZHUAHzlDZTUIHBwkAHsSbmAoA3JRQOCMKAAKLB1yABooADpK7iCZcSocyABKKjSEUhUNAD5sZnxuC2AkawLickae7W0kVm5oWnoTCl7J7QNgTgQSKAADAEkoVgEDqDpw6AHhgBIsatzytg4ecW3lyXEgA)

It is especially important to keep this in mind when working with React components, as their props tend to be destructured a lot.

So with all the cases, our code would look like this:

```ts:title=exhaustive-matching-in-ts
const renderShape = (shape: Shape): string => {
    switch (shape.kind) {
        case 'circle':
            return 'I am a circle'
        case 'rectangle':
            return 'I am a rectangle'
    }
}
```

[Typescript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAwglgJwMYBtoF4oG8BQV9QDWcAdgCYBcUA5EoqhNXgQgIZlwCuAzlSZwFsARhAQ4AvjlCQoAJQhJgrEgHM0UTLgJFSlGggVLVaJtoDucMsAAWfQSLHbrEOCuvA7w0RKnhoAZWtWGUx4ZHUAHzlDZTUIHBwkAHsSbmAoA3JRQOCMKAAKbiDIKhzIAEoqNIRSFQ0APmxmfG4LYCRrAqLcgDpicnKm7W0kVm5oWnoTCmbh7QNgTgQSGgBJKFYBDag6cMZZkbGJg0VY6YO5jIhF5bWNrdYr0+N97UlxIA)

Typescript is happy with this, and we will get a compile time error when we add a new `Shape` ðŸŽ‰

### Runtime caveats

