---
title: Syncing props to useState
description:
date: 2020-10-15
banner: ../dont-over-usestate/use-state-pitfalls.png
tags:
    - React
    - useState pitfalls
---

import Comments from 'components/Comments'
import { Divider } from '@theme-ui/components'

<img src="../dont-over-usestate/use-state-pitfalls.png" />

<Divider />

In the [first part](dont-over-use-state) of the useState pitfalls series,
I talked about avoiding state all together for derived state.

This part is about a common scenario, where we want to initialize our state with values we get as props.
This is something we probably do a lot, and it's not per-se wrong, but it has some potential issues that we need to be aware of.

### The example

I will use a classic list / detail use-case as example.
We have a list of users, and selecting one of them will result in a detail form being filled.
We want to show the users' email address in the detail form, and also have an apply button that will update that data.

It's an interactive example, so feel free to click around (the code is also editable):

```js react-live
const users = [
    {
        id: 1,
        name: 'Dominik',
        email: 'dominik@dorfmeister.cc',
    },
    {
        id: 2,
        name: 'John',
        email: 'john@doe.com',
    },
]

function App() {
    const [selected, setSelected] = React.useState(users[0])

    return (
        <div>
            {users.map((user) => (
                <button type="button" key={user.id} onClick={() => setSelected(user)}>
                    {user.id === selected.id ? user.name.toUpperCase() : user.name}
                </button>
            ))}
            <DetailView user={selected} />
        </div>
    )
}

function DetailView({ user }) {
    const [email, setEmail] = React.useState(user.email)

    return (
        <div>
            <input
                type="text"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
            />
            <button type="button" onClick={() => alert(email)}>
                Apply
            </button>
        </div>
    )
}

render(<App />)
```

### useState initial value

You might notice right away that the example is _not_ working.
You can edit the email address and click _Apply_, but if you click on _John_, the input field will not update.

As much as React wants us to [think in hooks](https://wattenberger.com/blog/react-hooks) rather than in lifecycles,
when it comes to state, there is a big difference between the first render (also known as _mount_) and further renders
(better known as re-renders).

The initial value of a useState hook is always _discarded_ on re-renders - it only has an effect when the component _mounts_.

When you click on _John_, the DetailView component will be re-rendered (because it already exists on the screen),
which means that John's email will not be put into our state.
Bummer, because we still need the local state to edit the email address (to keep the draft changes).
We don't want to update the user Array directly, because we might never click Apply.

I know three ways to handle this and similar use-cases:

<Comments>Leave a comment below ⬇️</Comments>
