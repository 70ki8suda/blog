---
title: Things to know about useState
description:
date: 2021-02-13
banner: ../dont-over-usestate/use-state-pitfalls.png
tags:
    - React
    - useState pitfalls
    - TypeScript
---

import Comments from 'components/Comments'
import { Divider } from '@theme-ui/components'

<img src="../dont-over-usestate/use-state-pitfalls.png" />

<Divider />

-   [#1: Don't over useState](dont-over-use-state)
-   [#2: Putting props to useState](putting-props-to-use-state)
-   <b>#3: Things to know about useState</b>

[useState](https://reactjs.org/docs/hooks-reference.html#usestate) is pretty straight forward to use. A value, a setter function, an initial state. What hidden gems could possibly be there to know about? Well, here are 5 things you can profit from on a daily basis that you might not have known about:

### 1: The functional updater

_setState_ had it, and _useState_ has it, too: The functional updater. Whenever you calculate the new result depending on the _previousValue_ of your state, you should use the functional updater:

```js:title=functional-updater
const [value, setValue] = React.useState(0)

// üö® depends on the current value to calculate the next value
<button onClick={() => setValue(value + 1)}>Increment</button>

// ‚úÖ uses previousValue to calculate next value
<button onClick={() => setValue(previousValue => previousValue + 1)}>Increment</button>
```

This might be totally irrelevant, but it might also introduce subtle bugs:

-   when you call the same setter multiple times in the same function.
-   when async setters are involved.

Kent C. Dodds has written a lengthy post about this [here](https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates), and the conclusion is:

> Any time I need to compute new state based on previous state, I use a function update.

<p style="padding-left: 3rem; margin-top: -1rem">‚Äî Kent C. Dodds</p>

#### Bonus: Toggling state with useReducer

Toggling a Boolean state value is likely something that you've done once or twice before. Judging by the above rule, it becomes a bit boilerplate-y:

```js:title=üö®-toggle-with-use-state
const [value, setValue] = React.useState(true)

<button onClick={() => setValue(perviousValue => !previousValue)}>Toggle</button>
```

If the only thing you want to do is toggle the state value, maybe even multiple times in one component, _useReducer_ might be the better choice, as it:

-   shifts the toggling logic from your component to the hook call
-   allows you to name your toggle function, as it's not just a setter
-   reduces boilerplate if you use the toggle function more than once

```js:title=‚úÖ-toggle-with-use-reducer
const [value, toggleValue] = React.useReducer(previousValue => !previousValue, true)

<button onClick={toggleValue}>Toggle</button>
```

I think this shows quite well that reducers don't have to be "complex", and you don't need to dispatch events with it at all costs. It all depends on the use case.

### 2: The lazy initializer

When we pass an initial value to _useState_, the initial variable is always created, but React will only use it for the first render. This is totally irrelevant for most use cases, e.g. when you pass a string as initial value. In rare cases, we have to do a complex calculation to initialize our state. In these cases, we can pass a function as initial value to _useState_. React will only invoke this function when it really needs the result (= when the component mounts):

```js:title=lazy-initializer
// üö® will unnecessarily be computed on every render
const [value, setValue] = React.useState(calculateExpensiveInitialValue(props))

// ‚úÖ looks like a small difference, but the function is only called once
const [value, setValue] = React.useState(() => calculateExpensiveInitialValue(props))
```

### 3: The update bailout

When you call the updater function, React will not always re-render your component. It will bail out of rendering if you try to update to the same value that your state is currently holding. React uses [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#description) to determine if the values are different. See for yourself in this live example:

```js react-live
function App() {
    const [name, setName] = React.useState('Dominik')

    // ü§Ø clicking this button will not re-render the component
    return (
        <button onClick={() => setName('Dominik')}>
            Name is: {name}, Date is: {new Date().getTime()}
        </button>
    )
}

render(<App />)
```

### 4: The convenience overload

This one is for all TypeScript users out there. Type inference for _useState_ usually works great, but if you want to initialize your value with _undefined_ or _null_, you usually need to explicitly specify the generic parameter, because otherwise, TypeScript will not have enough information:

```ts:title=use-state-type-inferrence
// üö® age will be inferred to `undefined` which is kinda useless
const [age, setAge] = React.useState(undefined)

// üÜó but a bit lengthy
const [age, setAge] = React.useState<number | null>(null)
```

Luckily, there is a [convenience overload](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/7a0d9c019f2b48b36b88691247870e6885b97a02/types/react/v16/index.d.ts#L921-L928) of _useState_ that will add _undefined_ to our passed type if we completely omit the initial value. It will also be _undefined_ at runtime, because not passing a parameter at all is equivalent to passing _undefined_ explicitly:

```ts:title=use-state-convenience-overload
// ‚úÖ age will be `number | undefined`
const [age, setAge] = React.useState<number>()
```

Of course, if you absolutely have to initialize with _null_, you need the lengthy version.

### 5: The implementation detail

_useState_ is (kinda) implemented with _useReducer_ under the hood. You can see this in [the source code here](https://github.com/facebook/react/blob/1a7472624661270008011fd77f097d71e6249de9/packages/react-reconciler/src/ReactFiberHooks.new.js#L1242-L1246). There is also a great article by Kent C. Dodds on [how to implement useState with useReducer](https://kentcdodds.com/blog/how-to-implement-usestate-with-usereducer).

### Conclusion

The first 3 of those 5 things are actually mentioned directly in the Hooks API Reference of the official React docs I linked to at the very beginning üòâ. But if you didn't know about these things before - now you do!

<Comments>How many of these things did you know? Leave a comment below ‚¨áÔ∏è</Comments>
