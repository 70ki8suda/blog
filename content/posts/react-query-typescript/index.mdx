---
title: React Query and TypeScript
description:
date: 2021-05-14
banner: ./react-query-typescript.jpeg
tags:
    - react
    - react-query
    - TypeScript
---

import Comments from 'components/Comments'
import Attribution from 'components/Attribution'

<img src="./react-query-typescript.jpeg" />

<Attribution name="hue12 photography" url="https://unsplash.com/@hue12_photography" />

-   [#1: Practical React Query](practical-react-query)
-   [#2: React Query Data Transformations](react-query-data-transformations)
-   [#3: React Query Render Optimizations](react-query-render-optimizations)
-   [#4: Status Checks in React Query](status-checks-in-react-query)
-   [#5: Testing React Query](testing-react-query)
-   <b>#6: React Query and TypeScript</b>

---

[TypeScript](https://www.typescriptlang.org/) is üî• - this seems to be a common understanding now in the Frontend community. Many developers expect libraries to either be written in TypeScript, or at least provide good type definitions. For me, if a library is written in TypeScript, the type definitions are the best documentation there is. It's never wrong because it directly reflects the implementation. I frequently look at type definitions before I read API docs.

React Query was initially written in JavaScript (v1), and was then re-written to TypeScript with v2. This means that right now, there is very good support for TypeScript consumers.

There are however a couple of "gotchas" when working with TypeScript due to how dynamic and unopinionated React Query is. Let's go through them one by one to make your experience with it even better.

### Generics

React Query heavily uses [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html). This is necessary because the library does not actually fetch data for you, and it cannot know what _type_ the data will have that your api returns.

The TypeScript section in the [official docs](https://react-query.tanstack.com/typescript) is not very extensive, and it tells us to explicitly specify the Generics that _useQuery_ expects when calling it:

```ts:title=explicit-generics
function useGroups() {
    return useQuery<Group[], Error>('groups', fetchGroups)
}
```

Over time, React Query has added more Generics to the _useQuery_ hook (there are now four of them), mainly because more functionality was added. The above code works, and it will make sure that the _data_ property of our custom hook is correctly typed to `Group[] | undefined` as well as that our _error_ will be of type `Error | undefined`. But it will not work like that for more advanced use-cases, especially when the other two Generics are needed.

#### The four Generics

This is the current definition of the _useQuery_ hook:

```ts:title=useQuery
export function useQuery<
    TQueryFnData = unknown,
    TError = unknown,
    TData = TQueryFnData,
    TQueryKey extends QueryKey = QueryKey
>
```

There's a lot of stuff going on, so let's try to break it down:

-   `TQueryFnData`: the type returned from the _queryFn_. In the above example, it's `Group[]`
-   `TError`: the type of Errors to expect from the _queryFn_. `Error` in the example
-   `TData`: the type our _data_ property will eventually have. Only relevant if you use the _select_ option, because then the _data_ property can be different from what the _queryFn_ returns. Otherwise, it will default to whatever the _queryFn_ returns.
-   `TQueryKey`: the type of our QueryKey, only relevant if you use the QueryKey that is passed to your _queryFn_.

As you can also see, all those Generics have default values, which means that if you don't provide them, TypeScript will fall back to those types. This works pretty much the same as default parameters in JavaScript:

```js:title=default-parameters
function multiply(a, b = 2) {
    return a * b
}

multiply(10) // ‚úÖ 20
multiply(10, 3) // ‚úÖ 30
```

There is one important difference between default Generics and default parameters: If you leave out all Generics, TypeScript will try _infer_ them from their usage, which is super awesome. However, as soon as you provide one of them, you have to provide _all_ of them. And because we have default values for our Generics, we might not notice right away that they will be taken. The resulting error messages can be quite cryptic. Let's look at an example where this actually backfires:

```ts:title=default-generics
function useGroupCount() {
    return useQuery<Group[], Error>('groups', fetchGroups, {
        select: (groups) => groups.length,
        // üö® Type '(groups: Group[]) => number' is not assignable to type '(data: Group[]) => Group[]'.
        // Type 'number' is not assignable to type 'Group[]'.ts(2322)
    })
}
```

Because we haven't provided the 3rd Generic, the default value kicks in, which is also `Group[]`, but we return `number` from our _select_ function. One fix is to add the 3rd Generic:

```ts:title=third-generic {3}
function useGroupCount() {
    // ‚úÖ fixed it
    return useQuery<Group[], Error, number>('groups', fetchGroups, {
        select: (groups) => groups.length,
    })
}
```

There is an [open issue](https://github.com/microsoft/TypeScript/issues/26242) in TypeScript about Partial Type Argument Inference, but as long as we don't have it, we have to work with what we got.

So what's the alternative?

#### Infer all the things

Let's start by _not_ passing in any Generics at all and let TypeScript figure out what to do. For this to work, we need the _queryFn_ to have a good return type. Of course, if you inline that function, you will have _any_ - because that's what _axios_ or _fetch_ give you:

```ts:title=inlined-queryFn
function useGroups() {
    // üö® data will be any here
    return useQuery(
        'groups',
        axios.get('groups').then((response) => respone.data)
    )
}
```

If you (like me) like to keep your api layer separated from your queries, you'll need to add type definitions anyways to avoid _implicit any_, so React Query can infer the rest:

```ts:title=inferred-types
function fetchGroups(): Promise<Group[]> {
    return axios.get('groups').then((response) => response.data)
}

// ‚úÖ data will be Group[] | undefined here
function useGroups() {
    return useQuery('groups', fetchGroups)
}

// ‚úÖ data will be number | undefined here
function useGroupCount() {
    return useQuery('groups', fetchGroups, {
        select: (groups) => groups.length,
    })
}
```

Advantages of this approach are:

-   no more manually specifying Generics
-   works for cases where the 3rd (select) and 4th (QueryKey) Generic are used
-   will continue to work if more Generics are added
-   code is less confusing / looks more like JavaScript

#### What about error?

What about error, you might ask? Per default, without any Generics, error will be inferred to _unknown_. This might sound like a bug, why is it not _Error_? But it is actually on purpose, because in JavaScript, you can throw _anything_ - it doesn't have to be of type `Error`:

```js:title=totally-legit-throw-statements
throw 5
throw undefined
throw Symbol('foo')
```

Since React Query is not in charge of the function that returns the Promise, it also can't know what type of errors it might produce. So _unknown_ is correct. Once TypeScript allows skipping some generics when calling a function with multiple generics (see [this issue for more information](https://github.com/microsoft/TypeScript/issues/10571)), we could handle this better, but for now, if we need to work with errors and don't want to resort to passing Generics, we can narrow the type with an instanceof check:

```ts:title=narrow-with-instanceof
const groups = useGroups()

if (groups.error) {
    // üö® this doesn't work because: Object is of type 'unknown'.ts(2571)
    return <div>An error occurred: {groups.error.message}</div>
}

// ‚úÖ the instanceOf check narrows to type Error
if (groups.error instanceof Error) {
    return <div>An error occurred: {groups.error.message}</div>
}
```

Since we need to make some kind of check anyways to see if we have an error, the instanceof check doesn't look like a bad idea at all, and it will also make sure that our error actually has a property message at runtime.

### Type Narrowing

I rarely use destructuring when working with React Query. First of all, names like _data_ and _error_ are quite universal (purposefully so), so you'll likely rename them anyway. Keeping the whole object will keep the context of what data it is or where the error is coming from. It will further help TypeScript to narrow types when using the status field or one of the status booleans, which it cannot do if you use destructuring:

```ts:title=type-narrowing
const { data, isSuccess } = useGroups()
if (isSuccess) {
    // üö® data will still be `Group[] | undefined` here
}

const groupsQuery = useGroups()
if (groupsQuery.isSuccess) {
    // ‚úÖ groupsQuery.data will now be `Group[]`
}
```

This has nothing to do with React Query, it is just how TypeScript works. [@danvdk](https://twitter.com/danvdk) has a good explanation for this behaviour

https://twitter.com/danvdk/status/1363614288103964672

### Type safety with the enabled option

I've expressed my ‚ô•Ô∏è for the [enabled option](./practical-react-query#the-enabled-option-is-very-powerful) right from the start, but it can be a bit tricky on type level if you want to use it for [dependent queries](https://react-query.tanstack.com/guides/dependent-queries) and disable your query for as long as some parameters are not yet defined:

```ts:title=the-enabled-option
function fetchGroup(id: number): Promise<Group> {
    return axios.get(`group/${id}`).then((response) => response.data)
}

function useGroup(id: number | undefined) {
    return useQuery(['group', id], () => fetchGroup(id), { enabled: Boolean(id) })
    // üö® Argument of type 'number | undefined' is not assignable to parameter of type 'number'.
    //  Type 'undefined' is not assignable to type 'number'.ts(2345)
}
```

Technically, TypeScript is right, _id_ is possibly _undefined_: the _enabled_ option does not perform any type narrowing. Also, there are ways to bypass the _enabled_ option, for example by calling the _refetch_ method returned from _useQuery_. In that case, the _id_ might really be _undefined_.

I've found the best way to go here, if you don't like the [non-null assertion operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator), is to accept that _id_ can be _undefined_ and reject the Promise in the _queryFn_. It's a bit of duplication, but it's also explicit:

```ts:title=explicit-id-check
function fetchGroup(id: number | undefined): Promise<Group> {
    return typeof id === 'undefined' ?
        ? Promise.reject(new Error('Invalid id'))
        : axios.get(`group/${id}`).then((response) => response.data)
}

function useGroup(id: number | undefined) {
    return useQuery(['group', id], () => fetchGroup(id), { enabled: Boolean(id) })
}
```

---

That's it for today. Feel free to reach out to me on [twitter](https://twitter.com/tkdodo)
if you have any questions, or just leave a comment below ‚¨áÔ∏è

<Comments withSeparator={false} />
